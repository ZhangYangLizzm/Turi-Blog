---
sidebar: auto
---

# 面试题

## js 基础

### 闭包

Q：什么是闭包?闭包的作用?

E:

```js
function createCounter() {
  let count = 0;

  return function() {
    count++;
    console.log(count);
  };
}

const counter = createCounter();

counter(); // 输出：1
counter(); // 输出：2
counter(); // 输出：3
```

A：闭包指的是函数和函数所在的词法环境的组合。一个函数可以访问创建它时所在的词法环境中的变量和函数，即使这个函数在其他地方被调用，也可以访问这些变量和函数。闭包可以用来实现模块化、缓存变量等功能。  
**详细解释:**
在JavaScript中，函数在创建时会生成一个词法环境（Lexical Environment），这个词法环境记录了函数创建时所在的作用域链。作用域链是由当前执行上下文的变量对象和所有外层函数的变量对象组成的。在函数执行时，会先搜索当前作用域链中的变量对象，如果没有找到，就会继续向上搜索外层函数的变量对象，直到找到变量或者到达全局作用域。这个搜2索的过程叫做作用域链查找。

当函数返回时，它的词法环境会被保存在内存中，并被引用到它所在的作用域链中。这个引用关系就是闭包。返回的函数可以访问保存在内存中的词法环境中的变量和函数，即使这个函数在其他地方被调用，也可以访问这些变量和函数。在上面的计数器例子中，createCounter函数返回了一个函数，这个函数就是闭包，它可以访问createCounter函数中的count变量。每次调用返回的函数，都会访问到同一个闭包中的count变量，并且可以修改它的值。

### 原型和原型链

Q：什么是原型和原型链?

A:当你创建一个对象时，JavaScript会在背后帮你创建一个原型对象，每个对象都有一个原型对象。原型对象就是一个普通的对象，它包含了一些属性和方法。你可以通过对象的__proto__属性访问它的原型对象。  
原型对象也可以有自己的原型对象，这样就形成了原型链。当你在一个对象上访问一个属性或方法时，JavaScript会先在这个对象本身查找，如果找不到，就会去它的原型对象上查找，如果还找不到，就会继续沿着原型链往上查找，直到找到这个属性或方法，或者到达原型链的顶端，即Object.prototype。

**显式原型和隐式原型**
在JavaScript中，每个函数都有一个属性叫做prototype，它是一个对象。这个prototype对象就是函数的显式原型，它包含了一些属性和方法，可以被用来实现继承。

当你创建一个对象时，JavaScript会为它创建一个__proto__属性，指向创建这个对象的构造函数的prototype。这个__proto__属性就是对象的隐式原型，它指向对象的原型对象。

### 垃圾回收机制

JavaScript是一种高级语言，它使用了自动内存管理机制，即垃圾回收机制，来管理内存。垃圾回收机制的主要目的是自动寻找和释放不再使用的对象，以便释放内存空间。

在JavaScript中，垃圾回收器会定期扫描内存中的所有对象，找出哪些对象是不再被引用的，然后释放它们所占用的内存空间。具体来说，当一个对象不再被引用时，它就会被标记为可回收的垃圾对象。接着，垃圾回收器会清除这些垃圾对象所占用的内存空间，以便其他对象可以使用这些空间。

JavaScript中的垃圾回收器使用的是基于标记的垃圾回收算法，它会从一组根对象开始，递归地遍历所有从根对象出发能访问到的对象。如果一个对象没有被遍历到，则被视为不可达对象，可以被标记为垃圾对象。

## Vue

### 路由守卫

Vue Router 提供了全局前置守卫（beforeEach）、全局解析守卫（beforeResolve）、全局后置钩子（afterEach）以及路由独享的守卫（beforeEnter、beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave）。  

守卫作用：

- beforeEach：在每个路由跳转前触发，可用于进行全局的导航守卫逻辑，如身份验证、权限判断等。
- beforeResolve：在每个路由组件解析之前触发，常用于处理异步路由组件的加载逻辑。  
- afterEach：在每个路由跳转完成后触发，常用于进行日志记录、页面统计等操作。  
- beforeEnter：在路由独享的守卫中使用，可用于单个路由的导航守卫逻辑。  
- beforeRouteEnter：在进入路由前触发，用于处理进入路由前的异步逻辑，但此时无法访问组件实例。  
- beforeRouteUpdate：在路由参数发生变化时触发，用于处理路由参数变化后的逻辑。  
- beforeRouteLeave：在离开路由前触发，用于处理离开路由前的确认、保存等操作。  

### 底层原理

#### 什么是 Vue 的虚拟 DOM？它是如何工作的？

Vue 的虚拟 DOM 是一种轻量级的 JavaScript 对象树，用于描述真实 DOM 的结构和属性。
当 Vue 应用更新时，Vue 会通过比较新旧虚拟 DOM，找出差异（变更的部分），然后只更新差异部分的真实 DOM，从而提高性能。
虚拟 DOM 的工作原理如下：
Vue 会根据模板或渲染函数生成虚拟 DOM。
当数据发生变化时，Vue 会重新计算虚拟 DOM，并与之前的虚拟 DOM 进行比较。
Vue 会找出差异，即需要添加、删除或更新的节点。
最后，Vue 将差异应用于真实 DOM，只更新需要变更的部分，从而减少 DOM 操作的次数，提高性能。

#### Vue 的响应式系统是如何工作的？

Vue 的响应式系统通过拦截对数据的访问和修改来实现数据的响应式更新。
Vue 使用了 Object.defineProperty 或 Proxy（在 Vue 3 中）来实现数据拦截。
当一个响应式数据被访问时，Vue 会将当前的组件实例添加到依赖追踪器中，建立响应式的关联。
当数据发生变化时，Vue 会通知依赖追踪器，依赖追踪器会通知相关的组件进行重新渲染，以保持视图与数据的同步。

#### Vue 的依赖追踪是如何实现的？

Vue 的依赖追踪是通过 Watcher 和 Dep（依赖）来实现的。
每个响应式数据都会有一个对应的 Dep 对象，用来存储依赖该数据的 Watcher。
当一个响应式数据被访问时，会触发 getter 函数，将当前的 Watcher 添加到 Dep 中。
当数据发生变化时，会触发 setter 函数，通知 Dep 中的所有 Watcher 进行更新。
Watcher 是一个中介者，负责管理与依赖数据的关系，当依赖的数据发生变化时，Watcher 会通知相关的组件进行重新渲染。

#### Vue 是如何实现模板编译的？

Vue 的模板编译是将模板转换为渲染函数的过程。
首先，Vue 会将模板解析为抽象语法树（AST）。
然后，Vue 会根据 AST 生成渲染函数。
渲染函数可以直接被调用以生成虚拟 DOM，或者被编译为字符串形式的 JavaScript 代码，用于在运行时执行。
在编译过程中，Vue 还会进行优化，例如静态节点的提升和标记，以减少不必要的计算和生成的代码量。

#### Vue 的 diff 算法是什么？它是如何工作的？

Vue 的 diff 算法是用于比较两个虚拟 DOM 树的差异，并更新真实 DOM 的算法。
Vue 的 diff 算法采用了双端比较的策略，即同时从虚拟 DOM 树的头部和尾部开始比较。
比较过程中，Vue 会对节点进行三种操作：创建新节点、删除旧节点和更新节点。
Vue 的 diff 算法通过比较节点的标签、属性和子节点等来确定需要更新的部分，从而实现高效的更新操作。
diff 算法还会尽可能地复用已有的节点，以减少 DOM 的操作次数和性能开销。

### Vue3和Vue2的差异

**性能改进：**
Vue 3 采用了更快、更小的虚拟 DOM 渲染器，提供了更高的性能和更低的内存占用。
通过编译时的静态分析和优化，Vue 3 生成的代码比 Vue 2 更小，加载和运行速度更快。
Vue 3 在响应式系统、编译器和组件实例化等方面进行了优化，提高了整体性能。

**更好的 TypeScript 支持：**
Vue 3 在设计上更加友好地支持 TypeScript，并且 TypeScript 的类型定义也得到了改进和完善。
Vue 3 使用了新的编写方式，使得开发者能够更好地利用 TypeScript 的类型检查和提示功能。

**Composition API：**
Vue 3 引入了 Composition API，提供了一种更灵活、组合化的组件编写方式。
Composition API 允许开发者将相关的逻辑组织在一起，提高了代码的可读性、维护性和重用性。
Composition API 通过提供 setup() 函数，使得组件的逻辑可以以函数的形式进行组合，而不是依赖于选项对象的方式。

**更强大的响应式系统：**
Vue 3 的响应式系统进行了重写，提供了更强大和灵活的响应式能力。
Vue 3 中的响应式系统使用了基于 Proxy 的代理方式，相比 Vue 2 的 Object.defineProperty，具有更好的性能和更全面的特性。
Vue 3 的响应式系统还支持了响应式的数组操作，如通过 ref() 和 reactive() 创建的数组可以直接使用数组方法进行修改。
